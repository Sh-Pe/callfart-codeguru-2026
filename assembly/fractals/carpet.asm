%define bomb 0x69; stack: CX interation counter, DX size, SI=offset; AX for manipulations; BX as direct adress and as denominator; CX for loop iterations; DX for current size; SI for the offsetMOV DL, 0xF3   ; highest power of 3 that fits within a nibbleMOV DI, 5h     ; iteration counterbegin:    ; if too deep into recursion, end func call    CMP DI, 0    JZ end_rec_call    ; DX <- size/3        MOV BL, 3h        MOV AX, DX        DIV byte BL        MOV DX, AX    ; init the loop    MOV CX, 00;    squares:        CMP CX, 9h ; loop finished, functioned ended        JZ end_rec_call        ; skip center iff i == j == 1        CMP CX, 4h        JZ skip_center        branch:        MOV BL, 3h        MOV AX, CX        DIV byte BL     ; AH=:i, AL=:j        ; calc offset            MOV BX, DX            MUL word DX ; AX <= (i * size/3, j * size/3), DX <= 0            ADD AX, SI  ; AX <+ offset            MOV DX, BX            MOV BX, AX  ; use BX as effective adress        ; draw (AX cannot be used as an effective adress)        MOV byte [BX], bomb        PUSH SI ; push the offset        PUSH DX ; push the current size        PUSH CX ; push the loop iteration        MOV SI, AX ; offset for next rec call is the calculated adress        DEC DI     ; into recursion        JMP begin        end_rec_call:            POP CX ; put into CX the loop iteration            INC CX ; because loop, should increment when loop run finishes            POP DX ; put into DX the current size            POP SI ; put into SI the offset            INC DI ; out of recursion, can increment back DI (instead of pushing/popping it from that stack)            JMP squaresskip_center:    INC CX    JMP branch